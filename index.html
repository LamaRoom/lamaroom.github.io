<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KK Dashboard Viewer (Fixed Fast Mode)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 2em; max-width: 900px; margin: auto; color:#222; }
    input, button, select { padding: 0.45em 0.6em; margin: 0.4em 0.4em 0.4em 0; font-size: 0.95rem; }
    .record, .missing { padding: 0.45em 0; border-bottom: 1px solid #eee; display:flex; align-items:center; justify-content:space-between; gap:1rem; }
    .record .left { display:flex; align-items:center; gap:0.6rem; flex:1; }
    .error { color: #c00; }
    h2 { margin-top: 1.6em; }
    .rank, .time { font-weight: 600; color: #0077cc; margin-left: 0.5em; }
    #progressBarWrap { width:100%; background:#f2f2f2; height:12px; border-radius:8px; overflow:hidden; margin-top:8px; display:none; }
    #progressBar { height:100%; width:0%; transition:width .18s linear; background: linear-gradient(90deg,#6bb1ff,#2b7be6); }
    #status { margin-top:0.5em; min-height:1.2em; color:#333; }
    a { color: inherit; text-decoration:underline; }
    .small { font-size: 0.88rem; color: #666; margin-left: 0.6rem; }
    .btn-row { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; margin-bottom: 0.6rem; }
  </style>
</head>
<body>
  <h1>KK Dashboard Viewer ‚Äî Fixed Fast Mode</h1>

  <div class="btn-row">
    <input id="pidInput" type="text" placeholder="Enter PID or full player URL" style="flex:1; min-width:260px" />
    <button id="fetchBtn">Fetch Records & Missing Maps</button>
    <button id="loadBtn">Load Times (fast)</button>
    <button id="exportBtn">Export to Google Sheets</button>

    <label class="small">Concurrency:
      <select id="concurrency" title="How many parallel requests to run">
        <option value="3">3</option>
        <option value="5" selected>5</option>
        <option value="8">8</option>
        <option value="12">12</option>
      </select>
    </label>

    <label class="small">Retries:
      <select id="retries" title="Retry attempts for failed requests">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
      </select>
    </label>
  </div>

  <div id="status"></div>
  <div id="progressBarWrap"><div id="progressBar"></div></div>

  <h2>Finished Maps</h2>
  <div id="recordsList"></div>

  <h2>Missing Maps</h2>
  <div id="missingList"></div>

  <script>
    // === Config / constants ===
    const GAS_URL = "https://script.google.com/macros/s/AKfycbyQsuyDAC-hwbrFuuOWu4uL8FNl1ryKgMuGFeqCoXZvtweCSlX_nj1zyfS4sGeERbGK/exec";
    const PROXY_BASE = 'https://spring-mode-00a0.ltomek05.workers.dev/?url='; // simple CORS proxy
    const BASE_BACKOFF_MS = 250;
    const BACKOFF_FACTOR = 1.6;
    const JITTER_MS = 120;

    // === State ===
    let allFinishedMaps = [];   // {name, rank, uid, time}
    let currentPid = '';
    window.currentPlayerName = '';

    // === Utils ===
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function cleanName(name) { return name ? name.replace(/\$[0-9a-zA-Z]{1,3}/g, '').trim() : ''; }
    function getSavedPID() {
      const saved = localStorage.getItem("kk_pid");
      if (saved) document.getElementById("pidInput").value = saved;
    }
    window.onload = getSavedPID;

    // Progress UI helper
    function updateProgress(done, total) {
      const wrap = document.getElementById('progressBarWrap');
      const bar = document.getElementById('progressBar');
      const status = document.getElementById('status');
      if (!total || total === 0) {
        wrap.style.display = 'none';
        bar.style.width = '0%';
        status.textContent = '';
        return;
      }
      const pct = Math.round((done / total) * 100);
      wrap.style.display = 'block';
      bar.style.width = pct + '%';
      status.textContent = `‚è± Fetching times: ${done}/${total} (${pct}%)`;
    }

    // === Fetch records & missing maps (original logic restored) ===
    async function fetchAll() {
      const input = document.getElementById('pidInput').value.trim();
      const status = document.getElementById('status');
      const recordsList = document.getElementById('recordsList');
      const missingList = document.getElementById('missingList');
      status.textContent = '';
      recordsList.innerHTML = '';
      missingList.innerHTML = '';
      allFinishedMaps = [];
      updateProgress(0,0);
      window.currentPlayerName = '';

      let pid, edition = '0';
      const pidMatch = input.match(/pid=(\d+)/);
      const editionMatch = input.match(/edition=(\d+)/);

      if (pidMatch) {
        pid = pidMatch[1];
        edition = editionMatch ? editionMatch[1] : '0';
      } else if (/^\d+$/.test(input)) {
        pid = input;
        edition = prompt('Enter edition (e.g., 0 for all editions):', '0') || '0';
      } else {
        status.textContent = '‚ùó Please enter a PID or valid player URL.';
        status.className = 'error';
        return;
      }

      currentPid = pid;
      localStorage.setItem("kk_pid", pid);

      try {
        const rawUrl = `https://kackiestkacky.com/hunting/editions/edition_history.php?pid=${pid}&edition=${edition}`;
        const proxyUrl = PROXY_BASE + encodeURIComponent(rawUrl);
        const response = await fetch(proxyUrl);
        const json = await response.json();
        const data = JSON.parse(json.contents);

        const allFinished = [];

        // data is array of edition entries
        data.forEach(entry => {
          // store player name for name-based matching fallback
          if (!window.currentPlayerName && entry.PlayerName) {
            window.currentPlayerName = String(entry.PlayerName).trim();
          }
          if (entry.FinishedMaps && entry.RecordsMaps) {
            const [mapNamesRaw, mapUIDsRaw] = entry.FinishedMaps.split(';');
            const names = mapNamesRaw ? mapNamesRaw.split(',') : [];
            const uids = mapUIDsRaw ? mapUIDsRaw.split(',') : [];
            const ranks = entry.RecordsMaps ? entry.RecordsMaps.split(',') : [];
            names.forEach((name, i) => {
              const clean = cleanName(name);
              const uid = uids[i] || '';
              const rank = ranks[i] || '?';
              if (clean && clean.length > 1) {
                allFinished.push({ name: clean, rank, uid, time: '?' });
              }
            });
          }
        });

        allFinishedMaps = allFinished;
        const finishedCount = allFinished.length;

        // render finished list with stable data-idx
        allFinishedMaps.forEach((m, idx) => {
          const div = document.createElement('div');
          div.className = 'record';
          div.dataset.idx = String(idx);
          const left = document.createElement('div'); left.className = 'left';
          const link = m.uid
            ? `<a href="https://kackiestkacky.com/hunting/editions/maps.php?uid=${m.uid}" target="_blank" rel="noopener">${m.name}</a>`
            : m.name;
          left.innerHTML = link + ` <span class="rank">#${m.rank}</span>`;
          const right = document.createElement('div');
          right.innerHTML = `<span class="time">[load]</span>`;
          div.appendChild(left);
          div.appendChild(right);
          recordsList.appendChild(div);
        });

        // fetch missing maps
        try {
          const missingUrl = PROXY_BASE + encodeURIComponent(`https://kackiestkacky.com/hunting/editions/missing_maps.php?pid=${pid}&edition=${edition}`);
          const missingResp = await fetch(missingUrl);
          const missingJson = await missingResp.json();
          const parsed = JSON.parse(missingJson.contents);

          const unfinishedRaw = parsed[0]?.UnfinishedMaps || '';
          const [namePart, uidPart] = unfinishedRaw.split(';');
          const nameList = namePart ? namePart.split(',') : [];
          const uidList = uidPart ? uidPart.split(',') : [];

          const missingMaps = nameList
            .map((raw, i) => ({ name: cleanName(raw), uid: uidList[i] || '' }))
            .filter(map => map.name && map.name.length > 1);

          if (missingMaps.length === 0) {
            const none = document.createElement('div'); none.textContent = 'üéâ No missing maps!'; missingList.appendChild(none);
          } else {
            missingMaps.forEach(({ name, uid }) => {
              const div = document.createElement('div'); div.className = 'missing';
              const link = uid ? `<a href="https://kackiestkacky.com/hunting/editions/maps.php?uid=${uid}" target="_blank" rel="noopener">${name}</a>` : name;
              div.innerHTML = link;
              missingList.appendChild(div);
            });
          }

          status.textContent = `‚úÖ Found ${finishedCount} finished map(s), ${missingMaps.length} missing.`;
        } catch (eMissing) {
          console.warn('Missing maps fetch failed:', eMissing);
          status.textContent = `‚úÖ Found ${finishedCount} finished map(s). ‚ö†Ô∏è Missing maps could not be loaded.`;
        }

      } catch (e) {
        console.error('Record fetch failed:', e);
        status.textContent = '‚ùå Failed to fetch map records.';
        status.className = 'error';
      }
    }

    // === Safe parser helpers ===
    // Extract rows: return array of [match0, ...] objects from matchAll
    function extractRows(html) {
      return [...html.matchAll(/<tr[\s\S]*?<\/tr>/gi)];
    }

    // Return true if rowHtml contains pid=... (simple include)
    function rowContainsPid(rowHtml, pid) {
      if (!pid) return false;
      return rowHtml.includes(`pid=${pid}`);
    }

    // Extract <td> cell texts in order
    function extractTdTexts(rowHtml) {
      const cells = [];
      const re = /<td[^>]*>([\s\S]*?)<\/td>/gi;
      let m;
      while ((m = re.exec(rowHtml)) !== null) {
        // strip tags inside td
        const txt = m[1].replace(/<[^>]+>/g, '').trim();
        cells.push(txt);
      }
      return cells;
    }

    // Parse time-like strings to normalized format
    function normalizeRawTime(raw) {
      if (!raw) return null;
      const s = raw.replace(/&nbsp;|\s+/g, ' ').trim();
      // mm:ss.mmm
      const mmss = s.match(/^(\d{1,2}):(\d{2}(?:\.\d{1,3})?)$/);
      if (mmss) {
        const minutes = String(parseInt(mmss[1], 10)); // remove leading zeros
        return `${minutes}:${mmss[2]}`;
      }
      // seconds with decimal e.g., 23.456
      const sec = s.match(/^(\d+\.\d{1,3})$/);
      if (sec) return parseFloat(sec[1]).toString();
      // fallback search anywhere
      const generic = s.match(/(\d{1,2}:\d{2}\.\d{1,3})|(\d+\.\d{1,3})/);
      if (generic) return generic[0];
      return null;
    }

    // Try multiple strategies: pid link, player name, fallback to generic
    function parseTimeFromMapHtml(html, map, pid) {
      if (!html || typeof html !== 'string') return null;

      const rows = extractRows(html);

      // 1) prefer pid-based matching (fast)
      for (const r of rows) {
        const rowHtml = r[0];
        if (rowContainsPid(rowHtml, pid)) {
          const tdTexts = extractTdTexts(rowHtml);
          // preferred indices - try 2 then 1 then 0 like original
          const candidates = [2, 1, 0];
          for (const idx of candidates) {
            if (tdTexts[idx]) {
              const nt = normalizeRawTime(tdTexts[idx]);
              if (nt) return nt;
            }
          }
        }
      }

      // 2) player name fallback (if we have it)
      if (window.currentPlayerName) {
        const nameLower = window.currentPlayerName.toLowerCase();
        for (const r of rows) {
          const rowHtml = r[0];
          if (rowHtml.toLowerCase().includes(nameLower)) {
            const tdTexts = extractTdTexts(rowHtml);
            const candidates = [2, 1, 0];
            for (const idx of candidates) {
              if (tdTexts[idx]) {
                const nt = normalizeRawTime(tdTexts[idx]);
                if (nt) return nt;
              }
            }
          }
        }
      }

      // 3) generic fallback: search whole html for mm:ss.mmm or ss.mmm nearby
      const generic = html.match(/(\d{1,2}:\d{2}\.\d{1,3})|(\d+\.\d{1,3})/);
      if (generic) return normalizeRawTime(generic[0]);

      return null;
    }

    // === Throttled loader with retries + backoff (safe) ===
    async function loadTimes() {
      const status = document.getElementById('status');
      const concurrency = parseInt(document.getElementById('concurrency').value, 10) || 5;
      const maxRetries = parseInt(document.getElementById('retries').value, 10) || 3;
      const total = allFinishedMaps.length;

      if (total === 0) {
        alert("You must fetch maps first.");
        return;
      }

      // Build queue of indices that have a uid
      const queue = [];
      for (let i = 0; i < allFinishedMaps.length; i++) {
        const map = allFinishedMaps[i];
        const row = document.querySelector(`#recordsList [data-idx="${i}"]`);
        if (!map.uid) {
          if (row) row.querySelector('.time').textContent = '‚è± -';
        } else {
          queue.push(i);
        }
      }

      let completed = 0;
      let errorCount = 0;
      updateProgress(0, total);
      status.textContent = `‚è± Starting time fetch ‚Äî concurrency ${concurrency}, retries ${maxRetries}`;

      // worker function
      async function worker(workerId) {
        while (true) {
          const idx = queue.shift();
          if (typeof idx === 'undefined') return;
          const map = allFinishedMaps[idx];
          const row = document.querySelector(`#recordsList [data-idx="${idx}"]`);
          if (row) row.querySelector('.time').textContent = '‚è≥ fetching';

          let attempt = 0;
          let success = false;
          let lastError = null;

          while (attempt < maxRetries && !success) {
            attempt++;
            if (row) row.querySelector('.time').textContent = `‚è≥ retrying (${attempt}/${maxRetries})`;
            console.log(`Worker ${workerId} attempt ${attempt} for uid=${map.uid} (idx ${idx})`);
            try {
              // small polite stagger before each request
              const stagger = Math.round(60 + Math.random() * 120); // 60-180 ms
              await sleep(stagger);

              const url = `https://kackiestkacky.com/hunting/editions/maps.php?uid=${encodeURIComponent(map.uid)}&raw=1`;
              const proxyUrl = PROXY_BASE + encodeURIComponent(url);

              const resp = await fetch(proxyUrl, { method: 'GET' });
              if (!resp.ok) {
                throw new Error('HTTP ' + resp.status);
              }
              const json = await resp.json();
              const html = String(json.contents || '');

              const parsedTime = parseTimeFromMapHtml(html, map, currentPid);
              if (parsedTime) {
                map.time = parsedTime;
                if (row) row.querySelector('.time').textContent = `‚è± ${parsedTime}`;
                success = true;
                break;
              } else {
                // treat as parse failure
                throw new Error('parse-failed');
              }

            } catch (err) {
              lastError = err;
              console.warn(`Attempt ${attempt} failed for uid=${map.uid}:`, err);
              if (attempt < maxRetries) {
                const backoff = Math.round(BASE_BACKOFF_MS * Math.pow(BACKOFF_FACTOR, attempt - 1) + (Math.random() * JITTER_MS));
                console.log(`Waiting ${backoff}ms before retrying uid=${map.uid}`);
                await sleep(backoff);
              }
            }
          }

          if (!success) {
            errorCount++;
            if (row) row.querySelector('.time').textContent = `‚è± (failed)`;
            console.error(`All ${maxRetries} attempts failed for uid=${map.uid}. Last error:`, lastError);
          }

          completed++;
          updateProgress(completed, total);
        }
      }

      // spawn worker pool (size = min(concurrency, queue.length))
      const poolSize = Math.min(concurrency, queue.length || concurrency);
      const workers = [];
      for (let w = 0; w < poolSize; w++) workers.push(worker(w + 1));
      await Promise.all(workers);

      const statusMsg = `‚úÖ Times updated. Completed: ${completed}/${total}` + (errorCount ? ` ‚Äî failed: ${errorCount}` : '');
      document.getElementById('status').textContent = statusMsg;
      updateProgress(total, total);
      console.log('loadTimes finished:', statusMsg);
    }

    // === Export to Google Sheets (unchanged) ===
    async function exportToSheets() {
      const status = document.getElementById('status');
      if (allFinishedMaps.length === 0) {
        alert("You must load maps first.");
        return;
      }

      let sheetId = localStorage.getItem('kk_sheet_id');
      if (!sheetId) {
        sheetId = prompt("Enter your Google Sheet ID:");
        if (!sheetId) return;
        localStorage.setItem("kk_sheet_id", sheetId);
      }

      const textBlock = allFinishedMaps.map(m =>
        `${m.name}\t${m.time || '?'}\t${m.rank}`
      ).join("\n");

      const payload = {
        map_records: textBlock,
        sheet_id: sheetId
      };

      try {
        const res = await fetch(GAS_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const txt = await res.text();
        status.textContent = `üì§ Upload status: ${txt}`;
      } catch (err) {
        console.error(err);
        status.textContent = '‚ùå Failed to upload to Google Sheets.';
      }
    }

    // === Wiring ===
    document.getElementById('fetchBtn').addEventListener('click', fetchAll);
    document.getElementById('loadBtn').addEventListener('click', loadTimes);
    document.getElementById('exportBtn').addEventListener('click', exportToSheets);
    document.getElementById('pidInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') fetchAll(); });
  </script>
</body>
</html>
