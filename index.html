<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KK Dashboard Viewer (Fast Mode v2)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 2em; max-width: 900px; margin: auto; color:#222; }
    input, button, select { padding: 0.45em 0.6em; margin: 0.4em 0.4em 0.4em 0; font-size: 0.95rem; }
    .record, .missing { padding: 0.45em 0; border-bottom: 1px solid #eee; display:flex; align-items:center; justify-content:space-between; gap:1rem; }
    .record .left { display:flex; align-items:center; gap:0.6rem; flex:1; }
    .error { color: #c00; }
    h2 { margin-top: 1.6em; }
    .rank, .time { font-weight: 600; color: #0077cc; margin-left: 0.5em; }
    #progressBarWrap { width:100%; background:#f2f2f2; height:12px; border-radius:8px; overflow:hidden; margin-top:8px; display:none; }
    #progressBar { height:100%; width:0%; transition:width .18s linear; background: linear-gradient(90deg,#6bb1ff,#2b7be6); }
    #status { margin-top:0.5em; min-height:1.2em; color:#333; }
    a { color: inherit; text-decoration:underline; }
    .small { font-size: 0.88rem; color: #666; margin-left: 0.6rem; }
    .btn-row { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; margin-bottom: 0.6rem; }
  </style>
</head>
<body>
  <h1>KK Dashboard Viewer ‚Äî Fast Mode v2</h1>

  <div class="btn-row">
    <input id="pidInput" type="text" placeholder="Enter PID or full player URL" style="flex:1; min-width:260px" />
    <button id="fetchBtn">Fetch Records & Missing Maps</button>
    <button id="loadBtn">Load Times (fast)</button>
    <button id="exportBtn">Export to Google Sheets</button>

    <label class="small">Concurrency:
      <select id="concurrency" title="How many parallel requests to run">
        <option value="3">3</option>
        <option value="5" selected>5</option>
        <option value="8">8</option>
        <option value="12">12</option>
      </select>
    </label>

    <label class="small">Retries:
      <select id="retries" title="Retry attempts for failed requests">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
      </select>
    </label>
  </div>

  <div id="status"></div>
  <div id="progressBarWrap"><div id="progressBar"></div></div>

  <h2>Finished Maps</h2>
  <div id="recordsList"></div>

  <h2>Missing Maps</h2>
  <div id="missingList"></div>

  <script>
    // === Configuration ===
    const GAS_URL = "https://script.google.com/macros/s/AKfycbyQsuyDAC-hwbrFuuOWu4uL8FNl1ryKgMuGFeqCoXZvtweCSlX_nj1zyfS4sGeERbGK/exec";
    const PROXY_BASE = 'https://api.allorigins.win/get?url='; // simple CORS proxy used previously
    // polite defaults
    const DEFAULT_CONCURRENCY = 5;
    const DEFAULT_RETRIES = 3;
    const BASE_BACKOFF_MS = 300; // base backoff before retry
    const BACKOFF_FACTOR = 1.6;  // exponential factor
    const JITTER_MS = 120;      // random jitter added to wait times

    // === Runtime state ===
    let allFinishedMaps = [];
    let currentPid = '';
    window.currentPlayerName = ''; // used by parser fallback

    // === Utilities ===
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function cleanName(name) { return name ? name.replace(/\$[0-9a-zA-Z]{1,3}/g, '').trim() : ''; }
    function getSavedPID() {
      const saved = localStorage.getItem("kk_pid");
      if (saved) document.getElementById("pidInput").value = saved;
    }
    window.onload = getSavedPID;

    // Progress UI
    function updateProgress(done, total) {
      const wrap = document.getElementById('progressBarWrap');
      const bar = document.getElementById('progressBar');
      const status = document.getElementById('status');
      if (!total || total === 0) {
        wrap.style.display = 'none';
        bar.style.width = '0%';
        status.textContent = '';
        return;
      }
      const pct = Math.round((done / total) * 100);
      wrap.style.display = 'block';
      bar.style.width = pct + '%';
      status.textContent = `‚è± Fetching times: ${done}/${total} (${pct}%)`;
    }

    // === Fetch list of finished maps & missing maps ===
    async function fetchAll() {
      const input = document.getElementById('pidInput').value.trim();
      const status = document.getElementById('status');
      const recordsList = document.getElementById('recordsList');
      const missingList = document.getElementById('missingList');
      status.textContent = '';
      recordsList.innerHTML = '';
      missingList.innerHTML = '';
      allFinishedMaps = [];
      updateProgress(0,0);
      window.currentPlayerName = '';

      let pid, edition = '0';
      const pidMatch = input.match(/pid=(\d+)/);
      const editionMatch = input.match(/edition=(\d+)/);

      if (pidMatch) {
        pid = pidMatch[1];
        edition = editionMatch ? editionMatch[1] : '0';
      } else if (/^\d+$/.test(input)) {
        pid = input;
        // keep behaviour: prompt for edition
        edition = prompt('Enter edition (e.g., 0 for all editions):', '0') || '0';
      } else {
        status.textContent = '‚ùó Please enter a PID or valid player URL.';
        status.className = 'error';
        return;
      }

      currentPid = pid;
      localStorage.setItem("kk_pid", pid);

      // fetch edition_history via proxy
      try {
        const rawUrl = `https://kackiestkacky.com/hunting/editions/edition_history.php?pid=${pid}&edition=${edition}`;
        const proxyUrl = PROXY_BASE + encodeURIComponent(rawUrl);
        const response = await fetch(proxyUrl);
        const json = await response.json();
        const data = JSON.parse(json.contents);

        const allFinished = [];
        // track player name if available
        for (const entry of data) {
          if (!window.currentPlayerName && entry.PlayerName) {
            window.currentPlayerName = String(entry.PlayerName).trim();
          }
          if (entry.FinishedMaps && entry.RecordsMaps) {
            const [mapNamesRaw, mapUIDsRaw] = entry.FinishedMaps.split(';');
            const names = mapNamesRaw ? mapNamesRaw.split(',') : [];
            const uids = mapUIDsRaw ? mapUIDsRaw.split(',') : [];
            const ranks = entry.RecordsMaps ? entry.RecordsMaps.split(',') : [];
            names.forEach((name, i) => {
              const clean = cleanName(name);
              const uid = uids[i] || '';
              const rank = ranks[i] || '?';
              if (clean && clean.length > 1) allFinished.push({ name: clean, rank, uid, time: '?' });
            });
          }
        }

        allFinishedMaps = allFinished;
        const finishedCount = allFinished.length;

        // render list with data-idx to map DOM -> data index
        allFinishedMaps.forEach((m, idx) => {
          const div = document.createElement('div');
          div.className = 'record';
          div.dataset.idx = String(idx);
          const left = document.createElement('div'); left.className = 'left';
          const link = m.uid
            ? `<a href="https://kackiestkacky.com/hunting/editions/maps.php?uid=${m.uid}" target="_blank" rel="noopener">${m.name}</a>`
            : m.name;
          left.innerHTML = link + ` <span class="rank">#${m.rank}</span>`;
          const right = document.createElement('div');
          right.innerHTML = `<span class="time">[load]</span>`;
          div.appendChild(left);
          div.appendChild(right);
          recordsList.appendChild(div);
        });

        // fetch missing maps (best-effort)
        try {
          const missingUrl = PROXY_BASE + encodeURIComponent(`https://kackiestkacky.com/hunting/editions/missing_maps.php?pid=${pid}&edition=${edition}`);
          const missingResp = await fetch(missingUrl);
          const missingJson = await missingResp.json();
          const parsed = JSON.parse(missingJson.contents);
          const unfinishedRaw = parsed[0]?.UnfinishedMaps || '';
          const [namePart, uidPart] = unfinishedRaw.split(';');
          const nameList = namePart ? namePart.split(',') : [];
          const uidList = uidPart ? uidPart.split(',') : [];

          const missingMaps = nameList
            .map((raw, i) => ({ name: cleanName(raw), uid: uidList[i] || '' }))
            .filter(map => map.name && map.name.length > 1);

          if (missingMaps.length === 0) {
            const none = document.createElement('div'); none.textContent = 'üéâ No missing maps!'; missingList.appendChild(none);
          } else {
            missingMaps.forEach(({ name, uid }) => {
              const div = document.createElement('div'); div.className = 'missing';
              const link = uid ? `<a href="https://kackiestkacky.com/hunting/editions/maps.php?uid=${uid}" target="_blank" rel="noopener">${name}</a>` : name;
              div.innerHTML = link;
              missingList.appendChild(div);
            });
          }
          status.textContent = `‚úÖ Found ${finishedCount} finished map(s), ${missingMaps.length} missing.`;
        } catch (eMissing) {
          console.warn('Missing maps fetch failed:', eMissing);
          status.textContent = `‚úÖ Found ${finishedCount} finished map(s). ‚ö†Ô∏è Missing maps could not be loaded.`;
        }

      } catch (e) {
        console.error('Record fetch failed:', e);
        status.textContent = '‚ùå Failed to fetch map records.';
        status.className = 'error';
      }
    }

    // === Robust parser: try to get player row time ===
    // Accepts HTML string and map info; returns string time or null on parse failure.
    function parseTimeFromMapHtml(html, map, pid) {
      if (!html || typeof html !== 'string') return null;

      // 1) try to find a pid link (fast-path)
      const pidRegex = new RegExp(`pid=(?:\\D*)${pid}\\b`);
      if (pid && pidRegex.test(html)) {
        // find the nearest <tr> that contains that pid
        const trMatch = html.match(new RegExp(`<tr[\\s\\S]*?pid=[^>]*${pid}[^>]*[\\s\\S]*?<\\/tr>`, 'i'));
        if (trMatch) {
          const rowHtml = trMatch[0];
          const cells = [...rowHtml.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/g)].map(m => m[1].trim());
          // time usually in 3rd cell, but try several indices
          const possible = [2,1,0];
          for (const idx of possible) {
            if (cells[idx]) {
              const text = cells[idx].replace(/<[^>]+>/g, '').trim();
              if (text) return normalizeRawTime(text);
            }
          }
        }
      }

      // 2) try by player name if available (case-insensitive)
      if (window.currentPlayerName) {
        const name = window.currentPlayerName.toLowerCase();
        const rows = [...html.matchAll(/<tr[\\s\\S]*?>[\\s\\S]*?<\\/tr>/gi)];
        for (const r of rows) {
          const rowHtml = r[0];
          if (rowHtml.toLowerCase().includes(name)) {
            const cells = [...rowHtml.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/g)].map(m => m[1].trim());
            const possible = [2,1,0];
            for (const idx of possible) {
              if (cells[idx]) {
                const text = cells[idx].replace(/<[^>]+>/g, '').trim();
                if (text) return normalizeRawTime(text);
              }
            }
          }
        }
      }

      // 3) fallback: try to find any time-like pattern in the HTML (mm:ss.mmm or ss.mmm)
      const generic = html.match(/(\\d{1,2}:\\d{2}\\.\\d{1,3})|(?:\\b\\d+\\.\\d{1,3}\\b)/);
      if (generic) return normalizeRawTime(generic[0]);

      return null;
    }

    // Normalize raw time strings to either "M:SS.mmm" or "SS.mmm" trimmed form
    function normalizeRawTime(raw) {
      const s = raw.replace(/&nbsp;|\\s+/g,' ').trim();
      // if contains colon e.g., 00:23.456 or 1:23.456
      if (s.includes(':')) {
        const parts = s.split(':').map(p => p.trim());
        const minutes = parts[0].replace(/^0+/, '') || '0';
        const rest = parts.slice(1).join(':');
        return `${minutes}:${rest}`;
      }
      // if plain seconds like "23.456"
      if (/^\\d+\\.\\d{1,3}$/.test(s)) {
        // trim leading zeros from seconds if needed (keep "0.123")
        return parseFloat(s).toString();
      }
      // fallback to s
      return s;
    }

    // === Throttled fetcher with retries + backoff ===
    async function loadTimes() {
      const status = document.getElementById('status');
      const concurrency = parseInt(document.getElementById('concurrency').value, 10) || DEFAULT_CONCURRENCY;
      const maxRetries = parseInt(document.getElementById('retries').value, 10) || DEFAULT_RETRIES;
      const total = allFinishedMaps.length;

      if (total === 0) {
        alert("You must fetch maps first.");
        return;
      }

      // prepare queue: indices of maps that have a uid (we only fetch pages for maps with uid)
      const queue = [];
      for (let i = 0; i < allFinishedMaps.length; i++) {
        const map = allFinishedMaps[i];
        // pre-mark rows with no uid
        const row = document.querySelector(`#recordsList [data-idx="${i}"]`);
        if (!map.uid) {
          if (row) row.querySelector('.time').textContent = '‚è± -';
        } else {
          queue.push(i);
        }
      }

      let completed = 0;
      let errorCount = 0;
      updateProgress(0, total);
      status.textContent = `‚è± Starting time fetch ‚Äî concurrency ${concurrency}, retries ${maxRetries}`;

      // worker function
      async function worker(workerId) {
        while (true) {
          const idx = queue.shift();
          if (typeof idx === 'undefined') return;
          const map = allFinishedMaps[idx];
          const row = document.querySelector(`#recordsList [data-idx="${idx}"]`);
          if (row) row.querySelector('.time').textContent = '‚è≥ fetching';

          let attempt = 0;
          let success = false;
          let lastError = null;

          while (attempt < maxRetries && !success) {
            attempt++;
            if (row) row.querySelector('.time').textContent = `‚è≥ retrying (${attempt}/${maxRetries})`;
            console.log(`Worker ${workerId} attempt ${attempt} for uid=${map.uid} (idx ${idx})`);
            try {
              // small polite stagger before each request (randomized)
              const stagger = Math.round(60 + Math.random() * 120); // 60-180 ms
              await sleep(stagger);

              const url = `https://kackiestkacky.com/hunting/editions/maps.php?uid=${encodeURIComponent(map.uid)}&raw=1`;
              const proxyUrl = PROXY_BASE + encodeURIComponent(url);

              const resp = await fetch(proxyUrl, { method: 'GET' });
              if (!resp.ok) {
                throw new Error('HTTP ' + resp.status);
              }
              const json = await resp.json();
              const html = String(json.contents || '');

              // parse time
              const parsedTime = parseTimeFromMapHtml(html, map, currentPid);
              if (parsedTime) {
                map.time = parsedTime;
                if (row) row.querySelector('.time').textContent = `‚è± ${parsedTime}`;
                success = true;
                break;
              } else {
                // parsing seems to have failed even though server responded; treat as failure to parse
                throw new Error('parse-failed');
              }

            } catch (err) {
              lastError = err;
              console.warn(`Attempt ${attempt} failed for uid=${map.uid}:`, err);
              // if this was last try, break; otherwise wait with exponential backoff + jitter
              if (attempt < maxRetries) {
                const backoff = Math.round(BASE_BACKOFF_MS * Math.pow(BACKOFF_FACTOR, attempt - 1) + (Math.random() * JITTER_MS));
                // brief console log & wait
                console.log(`Waiting ${backoff}ms before retrying uid=${map.uid}`);
                await sleep(backoff);
              }
            }
          } // attempts loop

          if (!success) {
            errorCount++;
            if (row) row.querySelector('.time').textContent = `‚è± (failed)`;
            console.error(`All ${maxRetries} attempts failed for uid=${map.uid}. Last error:`, lastError);
          }

          completed++;
          updateProgress(completed, total);
        }
      }

      // spawn worker pool
      const poolSize = Math.min(concurrency, queue.length || concurrency);
      const workers = [];
      for (let w = 0; w < poolSize; w++) workers.push(worker(w + 1));
      await Promise.all(workers);

      const statusMsg = `‚úÖ Times updated. Completed: ${completed}/${total}` + (errorCount ? ` ‚Äî failed: ${errorCount}` : '');
      document.getElementById('status').textContent = statusMsg;
      updateProgress(total, total);
      console.log('loadTimes finished:', statusMsg);
    }

    // === Export to Google Sheets (unchanged) ===
    async function exportToSheets() {
      const status = document.getElementById('status');
      if (allFinishedMaps.length === 0) {
        alert("You must load maps first.");
        return;
      }

      let sheetId = localStorage.getItem('kk_sheet_id');
      if (!sheetId) {
        sheetId = prompt("Enter your Google Sheet ID:");
        if (!sheetId) return;
        localStorage.setItem("kk_sheet_id", sheetId);
      }

      const textBlock = allFinishedMaps.map(m =>
        `${m.name}\t${m.time || '?'}\t${m.rank}`
      ).join("\n");

      const payload = {
        map_records: textBlock,
        sheet_id: sheetId
      };

      try {
        const res = await fetch(GAS_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const txt = await res.text();
        status.textContent = `üì§ Upload status: ${txt}`;
      } catch (err) {
        console.error(err);
        status.textContent = '‚ùå Failed to upload to Google Sheets.';
      }
    }

    // === Wiring ===
    document.getElementById('fetchBtn').addEventListener('click', fetchAll);
    document.getElementById('loadBtn').addEventListener('click', loadTimes);
    document.getElementById('exportBtn').addEventListener('click', exportToSheets);
    document.getElementById('pidInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') fetchAll(); });
  </script>
</body>
</html>
