<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Kacky Time Fetcher</title>
<style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    button { padding: 8px 14px; margin: 5px; cursor: pointer; }
    input { padding: 6px; width: 120px; }
    .map { padding: 4px 0; }
    .status { color: #888; margin-left: 6px; }
    .time { font-weight: bold; }
</style>
</head>
<body>

<h2>Kacky Time Fetcher</h2>

<div>
    <label>UID: <input id="uid" type="text"></label>
    <button id="fetch">Fetch Times</button>
    <button id="clear">Clear</button>
</div>

<div id="maps"></div>

<script>
// -------------------------- //
// SAFE SIMPLE PARSER (Option C)
// -------------------------- //

// Extracts every <tr>...</tr> row
function extractRows(html) {
    return [...html.matchAll(/<tr[\s\S]*?<\/tr>/gi)];
}

// Picks the row containing the PID
function findRowByPid(rows, pid) {
    return rows.find(r => r[0].includes(`pid=${pid}`));
}

// Extracts the time from the row's HTML
function extractTime(rowHtml) {
    const m = rowHtml.match(/<td[^>]*class="time"[^>]*>(.*?)<\/td>/i);
    return m ? m[1].trim() : null;
}

// Full parse pipeline
function parseTimeFromHtml(html, pid) {
    const rows = extractRows(html);
    const row = findRowByPid(rows, pid);
    if (!row) return null;
    return extractTime(row[0]);
}

// -------------------------- //
// FETCH + RETRIES + BACKOFF
// -------------------------- //

async function fetchWithRetries(url, retries = 3, delay = 200) {
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error("HTTP " + res.status);
            return await res.json();   // AllOrigins returns JSON
        } catch (err) {
            if (attempt === retries) throw err;
            await new Promise(r => setTimeout(r, delay));
            delay *= 1.5; // backoff
        }
    }
}

// -------------------------- //
// CONCURRENCY LIMITER (5)
// -------------------------- //

async function runLimited(tasks, limit = 5) {
    const results = [];
    let i = 0;

    async function worker() {
        while (i < tasks.length) {
            const idx = i++;
            results[idx] = await tasks[idx]();
        }
    }

    const workers = [];
    for (let w = 0; w < limit; w++) workers.push(worker());
    await Promise.all(workers);

    return results;
}

// -------------------------- //
// UI + MAIN FETCH LOGIC
// -------------------------- //

document.getElementById("fetch").addEventListener("click", async () => {
    const uid = document.getElementById("uid").value.trim();
    if (!uid) return alert("Enter UID");

    const mapsDiv = document.getElementById("maps");
    mapsDiv.innerHTML = "";

    // Example map list – replace with your actual PIDs if needed
    const mapList = Array.from({ length: 95 }, (_, i) => i + 1);

    // Create UI entries
    mapList.forEach(pid => {
        const el = document.createElement("div");
        el.className = "map";
        el.id = "map-" + pid;
        el.innerHTML = `Map ${pid}: <span class="time">…</span><span class="status"></span>`;
        mapsDiv.appendChild(el);
    });

    // Build task array
    const tasks = mapList.map(pid => {
        return async () => {
            const row = document.getElementById("map-" + pid);
            const timeEl = row.querySelector(".time");
            const statusEl = row.querySelector(".status");

            statusEl.textContent = " (fetching…)";

            const url = `https://kackiestkacky.com/hunting/editions/maps.php?uid=${uid}&raw=1`;
            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

            let html = null;

            // 3 retry attempts
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    if (attempt > 1) statusEl.textContent = ` (retrying ${attempt}/3…)`;

                    const json = await fetchWithRetries(proxyUrl, 1); // 1 retry inside per attempt
                    html = json.contents;

                    const time = parseTimeFromHtml(html, pid);
                    if (time) {
                        timeEl.textContent = time;
                        statusEl.textContent = "";
                        return;
                    }
                } catch (err) {
                    // continue to next retry
                }

                // Wait before next retry (soft delay)
                await new Promise(r => setTimeout(r, 300 * attempt));
            }

            // All retries failed
            timeEl.textContent = "!";
            statusEl.textContent = " (failed)";
        };
    });

    // Run with concurrency limit
    await runLimited(tasks, 5);
});

document.getElementById("clear").addEventListener("click", () => {
    document.getElementById("maps").innerHTML = "";
});
</script>

</body>
</html>
